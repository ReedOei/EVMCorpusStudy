Spreadsheet is at: https://docs.google.com/spreadsheets/d/1iwOZTqvbSfDr-yUaQnZFvKJLhYJ4eRd7P9wpxmrd9Jc/edit?usp=sharing

States:
- About 47% of the contracts I looked at had some state
- Another thing we might want to try is looking at the analysis tools, they do things like look for transaction order dependence or timestamp dependence, which might also indicate state usage.

Ownership:
- We could try to infer ownership here? Not sure how easy or practical this would be, or maybe we'd just get like Shared references to everything.
    - We could treat when we can infer Owned/Unowned as a "success", when we have to use "Shared", then it's a "failure" (not that it's really a failure, but...)

Questions about transactions with exceptions:
- Could help us identify the usefulness of states, because failed transactions may reveal a mismatch of expectations between the caller and the smart contract.
    - Also, we know from that one Plaid study that having a language with states gives better documentation for when you're looking at state stuff, so this could help developers because they'll be working with state stuff.

TODO:
- Bugs that we wouldn't detect but would be good to detect.
    - Such as not losing references, but losing ability to work with the references.

- Maybe look for early returns?
    - Change some state but not all states that the function should change.

- Or fallback functions/payable functions that accept ether and don't do anything with the state.

- Look at other sources of blockchain contracts that are not just Ethereum because we have too many contracts that are just Tokens
    - Corta
    - Hyperledger
    - Or maybe the Ethereum testnet corpus
    - Or maybe GitHub solidity code
    - etc.

- How many times has each contract been invoked?
    - Could weight results by these numbers, giving a more accurate picture of the attributes of widely used contracts

- How similar are the various token contracts?
    - Maybe how many parameters would a token contract generator need to generate the full range?

- Conditions under which functions abort or return early:
    - How many are just checking an enum or checking complicated conditions?
    - Try running Slither to do this

- Work more on the research question document

