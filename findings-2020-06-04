Spreadsheet is at: https://docs.google.com/spreadsheets/d/1iwOZTqvbSfDr-yUaQnZFvKJLhYJ4eRd7P9wpxmrd9Jc/edit?usp=sharing
RQ doc is: https://docs.google.com/document/d/1qODEjhkqnH36iAAbZmSH68x_Mrs2WAxTQHW0q-3jwkw/edit?usp=sharing

- Had a hard time finding other corpuses of smart contracts to read
    - I ended up just reading more Solidity contracts, just from GitHub instead
    - The distribution did change:
    TODO: Figure out what it is
- Wrote some stuff down on RQ doc
    - TODO: Explain what I did, questions, etc.

    States:
    - Another thing we might want to try is looking at the analysis tools, they do things like look for transaction order dependence or timestamp dependence, which might also indicate state usage.

    Ownership:
    - We could try to infer ownership here? Not sure how easy or practical this would be, or maybe we'd just get like Shared references to everything.
        - We could treat when we can infer Owned/Unowned as a "success", when we have to use "Shared", then it's a "failure" (not that it's really a failure, but...)

    Questions about transactions with exceptions:
    - Could help us identify the usefulness of states, because failed transactions may reveal a mismatch of expectations between the caller and the smart contract.
        - Also, we know from that one Plaid study that having a language with states can give better documentation for when you're looking at state stuff, so this could help developers because they'll be working with state stuff.
-

TODO:
- Bugs that we wouldn't detect but would be good to detect.
    - Such as not losing references, but losing ability to work with the references.
        - Didn't see any of this.

- Maybe look for early returns?
    - Change some state but not all states that the function should change.
    - DID NOT DO

- Or fallback functions/payable functions that accept ether and don't do anything with the state.
    - DID NOT DO

- How many times has each contract been invoked?
    - Could weight results by these numbers, giving a more accurate picture of the attributes of widely used contracts
    - DID NOT DO

- How similar are the various token contracts?
    - Maybe how many parameters would a token contract generator need to generate the full range?
    - Need a mint, burn, increase/decrease allowance, Ownable, Pausable

- Conditions under which functions abort or return early:
    - How many are just checking an enum and how many are checking complicated conditions?
    - Try running Slither to do this

- Work more on the research question document

